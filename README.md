# Library
Вот сложное задание по Python, которое включает различные аспекты программирования, такие как работа с данными, 
алгоритмы и объектно-ориентированное программирование:

Задание: Реализация системы управления библиотекой

Описание
Вам нужно создать систему управления библиотекой, которая будет поддерживать следующие функции:

Добавление, удаление и поиск книг в библиотеке.
Регистрация пользователей библиотеки.
Взятие и возврат книг пользователями.
Ведение учета выдачи книг и возвратов.
Генерация отчетов о текущем состоянии библиотеки.
Требования
Классы и объекты:

Класс Book с атрибутами: id, title, author, year, is_checked_out.
Класс User с атрибутами: id, name, email.
Класс Library с атрибутами и методами для управления книгами и пользователями.
Методы класса Library:

add_book(book: Book) - добавление книги.
remove_book(book_id: int) - удаление книги по ID.
find_book(book_id: int) - поиск книги по ID.
register_user(user: User) - регистрация пользователя.
checkout_book(book_id: int, user_id: int) - выдача книги пользователю.
return_book(book_id: int, user_id: int) - возврат книги пользователем.
general_report() - генерация отчета о текущем состоянии библиотеки.
Исключения и обработка ошибок:

Обработка случаев, когда пользователь пытается взять уже взятую книгу.
Обработка случаев, когда пользователь пытается вернуть книгу, которая ему не выдавалась.


## Readme

В данном проекте имеется две версии:
1) Обычная, работает через терминал
2) На Flask

В данном README будет инструкция для обеих версий.

## Стек

- Python > 3.11
- requests
- typing
- Flask
- SQlite 3
- PyCharm Professional
- macOS Sonoma ver.14.4.1
- Git
- 
## Лицензия

MIT

## Общее описание работы кода (инструкция)
## 1. Library.py (обычная версия)

Все приложение состоит из двух классов:

1) class library_db - создание базы данных


__init__


    Конструктор создания и подключения к БД
    Создаем базу данных с названием, которое указываем в name_database и подключаемся к ней

create_tables


    Метод создания таблиц БД.
    В нашей базе данных будет две таблицы:
    Users_db - таблица пользователей, которых зарегистрировали в библиотеке
    Library_db - таблица с книгами, т.е. сама библиотека
    Поля таблиц:
    Users_db имеет 3 поля - 
    id 
    имя 
    почта

    Library_db имеет 7 полей - 
    id 
    название книги
    автор книги
    год написания книги
    флажок типа bool, указывающий на руках книга или в библиотеке
    уникальный номер книги
    id пользователя который взял книгу и ЕСЛИ взял, иначе null
    Последнее поле связано с полем id таблицы Users_db связью Многие-к-одному 
    через поле user_book_id

    Один пользователь может взять много книг, но конкретная книга может быть
    только у одного пользователя

Создаем экземпляр класса library_DB и вызываем метод сreate_tables, создавая таблицы

2) class Library - основной класс для работы с БД

init

    Конструктор создания атрибутов. Создадим один атрибут self.DB для удобных манипуляций с БД

1.last_number

    Статичный метод. В данном методе мы извлекаем уникальный номер последней книги в БД и возвращаем этот номер, 
    увеличенный на единицу. Сделан для упорядоченного размещения новой книги в библиотеке.
2.add_book

    Метод добавления книги в библиотеку
    В начале выводим сообщение, что именно нужно сделать? Добавить случайную книгу из Сети, добавить книгу вручную
    или выйти в главное меню.
    1) Добавить случайную книгу
    Сначала определяемся, сколько случайных книг хотим добавить в библиотеку
    Далее введенное число отправляем в параметр функции make_books.
    make_books - функция, которую я написал в файле Book и откуда, собственно, она импортируется
    -------------
    Во вспомогательном файле Book имеется class Book.
    В этом классе в атрибутах (в init) мы определяем данные для книги:
    Название, автора, год написания
    Метод generic data отвечает за "сбор" из Сети данны для книги. Воспользуемся библиотекой request:
    Сохраняем в переменную url ссылку на раздел онлайн библиотеки, который выдает случайную книгу при нажатии на кнопку.
    Важно: ссылка у нас именно на страницу ПОСЛЕ нажатия кнопки. Т.е. мы перехватываем данные, по факту ее не нажимая
    Парсим html код страницы с помощью bs4 для удобной работы далее
    С помощью регулярного выражения извлекаем название книги со страницы, избавлясь от пробелов в конце, если они
    появляются.
    Через soup.find_all находим класс информации о книге и сохраняем в book_info
    Из book_info с помощью регулярного вырдания вытаскиваем Имя Фамилию (и отчество при наличии) автора
    Дальше находим год написания через поиск четырехзначного строчного числа, если год оказываетя пустым - делаем равным
    нулю (год написан не ко всем книгам)
    Сохраняем извлеченные данные- название книги, автора, год в список
    Дополнительно указываем магический метод str, если нам понадобится проверить, какие книги находит переход по ссылке
    make_books - функция запускающая generic_data столько раз, сколько мы указали в классе Library количество случайных 
    книг
    Каждая книга - это один список из трех элементов: названия, автора, года. Все эти списки мы отправлем в главный
    список all_book_data  и возвращаем этот список в методе add_book
    ------------
    Вернув список в наш метод, мы пересохраняем его в переменную all_book_data
    Запускаем цикл счетчик, равный количеству случайных книг
    В цикле создаем уникальный номера для книг. Если у нас таблица пустая (стат. метод last_number возвращает False),
    то даем первой книге номер 1000, иначе - берем номер, возвращаемый last_number (последний номер + 1)
    Создаем основной список для книги: распакованный возврат функции make_books(переменная all_book_data), 
    1(значение по умолчанию, означающее, что книга в библиотеке), уникальный номер)
    запускаем вспомогательную функцию query_insert с параметром, в который закидываем наш список. В этой функции 
    осуществляем вставку книги в строку базы данных. И коммитим, подтвердив изменения.
    Такой же алгоритм совершаем с каждой случайной книгой из списка all_book_data
    2) Добавить книгу вручную
    Вводим для книги название, автора, года. Уникальный номер дается по аналогии с предыдущим услвоием.
    Полный список для книги создается по аналогии с предыдущим условием
    Запускаем фукнция query_insert по аналогии с предыдущим условием
    3) Вернуться в командам
    перезапуск фукнции main() - "включалки" нашего приложения
    Если вводим что-то другое - получаем сообщение об ошибке и перезапускаем метод.


