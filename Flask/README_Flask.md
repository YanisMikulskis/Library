## Readme for Flask
Здесь представлена вторая версия проекта "Библиотека".

Данная часть реализована с помощью Flask.

## Стек
- Python > 3.11
- Bootstrap
- CSS
- JavaScript
- HTML
- Flask > 3.0.3 
- Flask-Migrate > 4.0.7 
- SQLAlchemy 2.0.31 
- Jinja2 
- Mako > 1.3.5
- alembic > 1.13.2
- sqlite3
- PyCharm Professional
- macOS Sonoma ver.14.4.1
- Git

## Лицензия

MIT

# Общее описание работы кода (инструкция)
## Содержание проекта:
Данный проект содержит несколько .py модулей в основной директории:
1) app_library.py
    
    
    Основной модуль со всеми представлениями и логикой. 
    В нем будет вестись основная работа. Основной backend.
2) Book_for_Flask.py
    
   
    Модуль для генерации случайной книги из Сети 
    (с сайта readly.ru из раздела "Мне повезет"). Понадобится на странице "Добавление книги"
3) createDB
    
    
    модуль, несущий модели БД и подключение к нашей БД через SQLAlchemy - уникальной библиотеки,
    позволяющей "общаться" с базой данных с помощью языка Python (а не через SQL запросы)
4) session
    
    
    Вспомогательный файл для alembic - инструмента для создания и ведения миграций.
    Используется при первоначальной настройке и при последующем добавлении моделей. 

5) Library_Database_Flask


    Консоль для SQL запросов БД (не будет использоваться)

6) src 


    Папка для миграций. Содержит файл настроек для alembic (env.py), 
    'запускалку'(script.py.mako), readme и папку с версиями миграций

7) templates


    Шаблоны страниц. Основной frontend.

## Описание работы каждого файла

Начнем с createDB

1) connect

    
    Подключение к базе данных
2) engine


    Движок для sqlalchemy. В параметре указываем url базы данных. 
    Если БД локальная (у нас на ПК) - указываем тип БД и название. Если сетевая - сетевой URL
3) metadata


    Метаданные. Этот экземпляр класса MetaData() будет использоваться для создания таблиц-моделей (если их нет)

4) Base


    Унаследованный от класса DeclarativeBase подкласс. Будет использоваться для создания таблиц-моделей (если их нет)
    и работы с alembic (утилита для миграций). В настройки alembic мы будем, помимо моделей, импортировать и этот 
    подкласс.

5) Library_Flask


    Унаследованная от класса Base таблица модель. Создается при отсутствии. При наличии выполняет информативную роль.
    __tablename__ - Имя таблицы(Именно ТАБЛИЦЫ в рамках БД!).Взаимодействовать с ней будем через название класса.
    Дальше идут поля таблицы и описанием: первичный ключ в id, название книги,автора,год написания, наличие,
    уникальный номер, id пользователя, который взял книгу (если взял, иначе - null)
    Отдельным моментом стоит отметить users - это связующее звено между таблицей книг и пользователей. В данном
    контексте users - это связь многие-к-одному, показывающая, какие книги взял юзер. 
    __repr__ - магический метод, показывающий "официальное" представление данных строки таблицы

6) Base.metadata.create_all(bind=engine)


    Создание таблиц с использованием движка sqlalchemy/или подключение к сущ.таблицам этого движка

7) session

    
    Создание сессии работы с моделями. db_session - параметр, вызывающий функцию sessionmaker(), которую мы 
    сохранили выше в переменную. Используется для манипуляций с БД. Аналог курсора для SQLlite.


Модуль Book_for_Flask

Класс для "вытягивания" из Сети случайной книги.

1) Book


    Класс книги. В атрибутах: название, автор, год написания
    generic_data - метод генерации случайных данных. Алгоритм следующий:
    url - ссылка на раздел книжного сайта, в котором генерируется случайная книга
    request_url - get-запрос в данный раздел ("подключение" к нему)
    soup - парсинг кода данной страницы
    self.title - извлекаем нужные данные с помощью регулярного выражения из всех
    классов html-кода страницы с названием 'blvi__title'
    тоже самое делаем с self.author и self.year. Если год отсутствует - заменяем его нулем.
    сохраняем все три атрибута в список

2) make_books


    Функция для "извлечения" нескольких книг. Именно она импортируется в основной 
    модуль app_library. И работаем там мы с результатом ее возврата.


Модуль app_library

Основной модуль с представлениями и логикой.
app-регистрация Flask приложения
app.secret_key - секретный ключ. В данном проекте не будет использоваться.

Дальше идут представления. Все начинаются с @app.route и одно с @app.errorhandler.
Нет смысла постоянно прописывать тут эти команды, поэтому буду писать только url, которые затрагиваются


1) /

    
    Стартовая страница. Открывается при запуске приложения и переходе по ссылке отладчика.
    На этой странице нужно выбрать, куда мы хотим перейти: в основное меню библиотеки или в личный кабинет
    читателя.
    Конструкция href="{{ url_for(/url) }}" позволяет перейти в нужное представление.
    HTML-шаблон - 'start_page.html'


2) 404


    Кастомизированная страница ошибки. Ее можно указать в том случае, когда приложение падает.
    HTML-шаблон - 'error404.html'

3) login


    Страница авторищации. Авторизация проходит через email и пароль (если он задан)
    if request.method == POST - условие, если у нас запускается POST-запрос, т.е. если
    мы отправляем данные из формы на сервер.
    email_form - то, что мы написали в поле email (изначально идет в формате str)
    password_form - то, что мы написали в поле password (изначально идет в формате str) 
    или не напиcали, если пароль при регистрации не был указан (см. ниже /new_reader)
    username - с помощью slqalchemy извлекаем из БД имя читателя по его почте. Все почты
    уникальные, поэтому находим строку, в которой есть введенная почта и извлекаем имя из этой
    строки таблицы. Тоже самое делаем с паролем.
    Если мы ввели существующие данные, то теперь у нас есть имя пользователя и его хэш пароля, указанного
    при регистрации. Если пароль не был указан, то он равен None.
    Если он был указан, то мы сравниваем хэш введенного пароля с хэшем пароля в БД.
    Если все ок, то переходим через функцию redirect в представление личного кабинета /personal_area с 
    username и password. Они нам понадобятся в личном кабинете
    При ошибках возвращаем flash-сообщение о соответствующей ошибке
    
4) /personal_area


    Личный кабинет пользователя. Содержит приветствие и имя пользователя, который зашел. Сюда попадают переменные
    username и email_form. 
    Можно посмотреть список книг которые он взял.
    HTML-шаблон - 'spersonal_area.html'

5) /my_book


    Страница со списком книг, которые взял пользователь. на эту страницу мы переходим после клика по надписи
    "Мои книги". В html-шаблон попадают переменные username и email (в personal_area мы в email сохранили email_form).
    По переменной email мы через filter находим все книги, которые взял этот пользователь (или не взял). Если такой
    почты в БД нет - возвращаем ошибку 404 (и ее шаблон)
    HTML-шаблон - 'my_book.html'
    
6) /menu



    Главное меню. В него мы можем перейти на первом этапе нашего приложения (на стартовой странице)
    Содержит кнопки с выпадающими списками всех соновны команд работы с библиотекой, для каждой из которой есть свой
    шаблон. Они будут ниже.
    HTML-шаблон - 'menu.html'.


7) add_book


    Страница добавления новой книги. Тут у нас есть два пути: добавить книгу в ручную или добавить случайную
    книгу из сети с сайта readly.ru. Как работает функция извлечения случайной книги из сети описано выше
    (см. Book_for_flask.py).
    Логика выбора будет основавываться на отлавливании ошибки werkzeug.exceptions.BadRequestKeyError.
    Т.е. если мы выбираем вариант с сетью и отправляем POST-запрос на количество книг, которое надо извлечь-
    у нас появляется ошибка, так как питон пытается найти текст из заполнения форм в разделе ручного добавления книг.
    Если он его НЕ находит - появляется эта ошибка. И если она появляется, значит мы выбрали вариант с сетью. 
    На это и будем опираться.


8) add_book - ручное добавление



    Ручное добавление
    title_book, author_book, year_book - "реквесты". То, что мы написали в соответствующую форму в шаблоне.
    new_book - экземпляр класса Library_Flask. В него мы добавляем "реквесты" и прочие параметры, а именно:
    is_checked_out=1 - означает, что книга в библиотеке
    personal_number=get_number_book() - уникальный номер книги создается в функции. Он равен
    (номер последней книги в БД) + 1
    user_book_id = None - id пользователя, который взял книгу. Изначально значение равно None, так как нельзя 
    взять книгу из библиотеки до того, как она будет в эту библиотеку добавлена.
    data_book - список из названия, автора и года
    Если с ними все ок (она написаны) - добавляем в БД экземпляр класса new_book:
    db_session.add_all([new_book])
    И коммитим: db_session.commit()
    Книга добавлена


9) add_book - добавление из Сети

   
    Если мы отлавливаем ошибку werkzeug.exceptions.BadRequestKeyError - то добавляем книгу из сети.
    count_book - количество книг, которое мы ввели в шаблоне в поле ['count_book']
    books_network - результат выполнения импортированной функции make_books() из модуля Book_for_flask
    Если в поле count_book мы ввели цифру, то books_network = make_books(int(count_book)), иначе (не цифру) None
    После срабатывания функции, получаем случайную книгу, которая добавляется в БД после except.


10) remove_book - удаление книги из БД


    Такая же ситуация с отлавливанием ошибки. Отлавливаем при выборе с уадлением одной книги или нескольких.
    Если удаляем одну - находим ее по id, проверяем наличие и если все ок, то удаляем из базы и коммитим.
    При удалении нескольких, ставим правило на ввод - вводить цифры через запятую и только цифры тех id,
    которые есть в БД. Если все ок - производим удаление
    one_book_id_from_form - текст, которые введен в соотв форму
    some_book_id_from_form - тоже самое
    если ищем одну книгу, находим ее в БД по id. При ее наличии удаляем из БД.
    Если ищем несолько книг, проверяем наличие запятой в введенной строке, которую мы взяли из шаблона
    Если все ок:
    form_list_data - сплитуем строку по запятым
    all_id - выводим все id из базы
    Запускаем цикл по "сплитованной" строке (списку) и проверяем наличие каждого id в all_id.
    Если имеется, то True добавляем в id_check (заранее созданный пустой список), иначе - False
    Далее через all() проверяем список id_check. Если НЕ все элементы True (т.е. какого то/каких то id 
    нет в БД) - выводим флэш сообщение об этом
    Иначе: запускаем цикл по "отсплитованной" строке и удаляем книги по id
    Коммитим

11) search_book - поиск книги по id



    В шаблоне вводим книгу, которую хотим найти и нажимаем соответствующую кнопку. Перемещаемся в представления
    result_search - введенное значение id
    result_book - найденная по id книга
    Если книга существует:
    Проверяем, какое значение у поля user_book_id для этой книги. Если оно = None - ее никто не брал, т.е. она 
    в библиотеке. Иначе: с помощью sqlalchemy находим имя читателя, который взял эту книгу.
    Ниже выводим данные книги, в т.ч. где она находится.

12) new_reader - регистрация нового читателя


    Все по стандарту, вводим данные, затем делаем "реквест" в представлениях.
    name_reader - имя
    email_reader - почта
    email_domain - домен введенной почты
    domains - допустимые домены
    password_reader - пароль пользователя (если не нужен, то остается пустым)
    hashed_password - хэш пароля. Если пароль не задан, то = None, иначе "хэшим" через sha256.
    Проверяем почту. Если Домен введеннй почты есть в допустимых - создаем экземпляр класса User_Flask, заносим в бд и 
    коммитим. А также делаем rollback - сброс транзакции. Нужно, чтобы введенные данные не пересекались со следующими 
    введенными данными. Эту конструкцию можно просто запомнить и вставлять всегда после коммита.
    Если почта введена неправильно - выводим соответствующее сообщение. Если все ок - получаем нового читателя.


13) checkout_book - выдача книги читателю


    select_reader_id - введенный id пользователя в форму, которому выдаем книгу
    select_book_number - введенный номер книги, которую выдаем введенном пользователю
    reader - читатель по найденному id
    book - книга по найденному id
    Если они есть в БД (т.е. != None), проверяем, равно ли None значение user_book_id в строке книги в БД
    Если да(книга в библиотеке), то добавляем пользователю книгу через extend во внешний ключ books
    relationship), коммитим, обнуляем транзакцию.
    Иначе: выводим соответствующее сообщение.
    Если книги или пользователя нет в БД, выводим сообщение.


14) return_book - возврат книги читателем назад


    input_reader_id - введенный id пользователя в форму, который вовзвращает книгу
    input_book_number - введенный номер книги, которую возвращает читатель
    reader - читатель по найденному id
    book - книга по найденному id
    Если они есть в БД (т.е. != None), проверяем, НЕ равно ли None значение user_book_id в строке книги в БД
    Если НЕ равно(книга на руках), то приравниваем к None (если поле равно None - значит книга НЕ на руках,
    т.е. в библиотеке), коммитим.
    Иначе: выводим соответствующее сообщение.
    Если книги или пользователя нет в БД, выводим сообщение.


5) books_sorted_func - вспомогательная функция


    Вспомогательная функция сортировки книг по алфавиту, 
    которые на руках/которые в библиотеке. 


6) books_on_hand - книги на руках


    books_dict - словарь для вывода
    books_sorted - отсортированные книги, которые на руках (hand=True)
    Запускаем цикл по книгам, и для каждой выводим имя пользователя, у которого эта книга
    его почту и название самой книги. Данные читателя выводим с помощью sqlalchemy.
    Добавляем в начальный словарь данные и в шаблоне выводим книги.


7) books_in_library - книги в библиотеке


    Все тоже самое, только выводим для книг, которые в библиотеке. В последнем ключе выводим
    количество книг в библиотеке через конструкцию func.count и scalar().


8) general_report - общий отчет о состоянии библиотеки


    count_books - общее количество книг в библиотеке
    all_books_sorted - все книги в отсортированном по алфавиту порядке
    Выводим их через цикл в подробном виде.
    hand_books - количество книг на руках
    library_books - количество книг в библиотеке
    readers_count - количество читателей
    readers - все читатели. Выводим их данные (вместе с книгами, которые у них есть (0, если нет книги))
    readers_active - читатели, которые активны, т.е. взяли хотя бы одну книгу. Сначала находим их, а потом 
    выводим их имена.



Alembic

Для работы с миграциями я использовал инструмент alembic. Алгоритм настройки:

1. Если мы базу еще не создали. Базу мы создаем с помощью питоновского sqlite.
   Прописываем connect = sqlite3.connect('Library_Database_Flask')\
   cursor = connect.cursor() или что то аналогичное

2. Дальше работаем уже только с помощью sqlalchemy. Подключаемся к созданной базе, делаем движок и тд.\
   Прописываем таблицы через ООП. Каждая таблица - это модель. Прописываем все настройки.\
   Если база уже была создана, то мы делаем тоже самое, только классы таблиц будут уже не создавать таблицы, 
   а иметь только информационную пользу и будут юзаться алембиком для создания миграций. В любом случае, 
   в них мы всегда должны описывать таблицу

3. Устанавливаем алембик через PIP (pip install alembic)

4. Прописываем alembic init alembic

5. Создаем файлик session. Из нашего модуля с таблицами SQLalchemy импортируем туда класс Base\
   Затем создаем функцию, импортируем оставшиеся модели из модуля с таблицами SQLAlchemy и возвращаем Base

6. В файле env.py (который установился вместе с алембиком) прописываем:
   Переходим в директорию с файликом session (os.chdir('/Users/yanis/Desktop/Professional_PYCH/GitREPs/Library/Flask'))
   Импортируем функцию, которая возвращает Base (from session import get_base)
   target_metadata = get_base().metadata
   больше ничего не трогаем.

7. В файле alembic.ini устанавливаем путь к нашей БД и прописываем настройки:\
   script_location = src/migrations -- создает папку для миграций\
   prepend_sys_path = . src --- переходит в созданную папку src для взаимодействия со script.py.mako и env.py\
   sqlalchemy.url = sqlite:///Library_Database_Flask -- путь к бд SQLITE3

8. alembic revision --message='initial' --autogenerate: запуск тестовой миграции.\
   Если в ПЕРВОЙ миграции в upgrade и downgrade везде None значит все ок\
   alembic upgrade (downgrade) head: применить самую новую(самую старую) миграции.\
   Если нужна определенная - то вместо head пишем ее номер без(_сообщения в ней)

    
    
    

    
        


